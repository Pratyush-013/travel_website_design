<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Tree Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Soft shadow */
            padding: 1.5rem;
            max-width: 95vw; /* Increased max width */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
        }
        canvas {
            border: 1px solid #cbd5e1; /* Light gray border */
            background-color: #fdfefe; /* Slightly off-white for canvas */
            border-radius: 0.5rem;
            display: block;
            width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
            max-height: 80vh; /* Increased max canvas height */
        }
        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap; /* Allow controls to wrap on small screens */
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem; /* More rounded buttons */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: none; /* No default border */
        }
        .btn-primary {
            background-color: #3b82f6; /* Blue */
            color: white;
        }
        .btn-primary:hover {
            background-color: #2563eb; /* Darker blue */
            transform: translateY(-2px); /* Slight lift effect */
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Light gray */
            color: #334155; /* Darker text */
        }
        .btn-secondary:hover {
            background-color: #cbd5e1; /* Even darker gray */
            transform: translateY(-2px);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .step-info {
            font-size: 1.125rem; /* Larger text */
            font-weight: 500;
            color: #475569; /* Slate gray */
            text-align: center;
            min-height: 2.5rem; /* Reserve space to prevent layout shifts */
        }
        .node-circle {
            fill: #60a5fa; /* Blue for circles */
            stroke: #3b82f6;
            stroke-width: 2;
        }
        .node-text {
            font-size: 14px;
            fill: white;
            text-anchor: middle;
            alignment-baseline: central;
        }
        .label-text {
            font-size: 12px;
            fill: #334155;
            text-anchor: middle;
            alignment-baseline: central;
        }
        .line {
            stroke: #64748b; /* Gray for lines */
            stroke-width: 2;
        }
        .current-nodes-highlight {
            font-weight: bold;
            color: #059669; /* Green for highlighting active nodes */
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .container {
                max-width: 900px; /* Wider on desktop */
                padding: 2rem;
            }
            .controls {
                flex-wrap: nowrap; /* Keep controls in a single row on desktop */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-2xl font-bold text-gray-800 mb-4">Huffman Tree Construction</h1>
        <p class="step-info" id="step-info"></p>
        <canvas id="huffmanCanvas"></canvas>
        <div class="controls">
            <button id="prevBtn" class="btn btn-secondary">Previous Step</button>
            <button id="nextBtn" class="btn btn-primary">Next Step</button>
            <button id="resetBtn" class="btn btn-secondary">Reset</button>
        </div>
    </div>

    <script>
        // Get canvas and its context
        const canvas = document.getElementById('huffmanCanvas');
        const ctx = canvas.getContext('2d');
        const stepInfoElement = document.getElementById('step-info');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const resetBtn = document.getElementById('resetBtn');

        // Initial character frequencies based on your provided image
        const initialFrequencies = [
            { char: 'A', freq: 4 },
            { char: 'B', freq: 7 },
            { char: 'C', freq: 3 },
            { char: 'D', freq: 2 },
            { char: 'E', freq: 4 },
        ];

        let steps = []; // Stores the state of the tree at each step
        let currentStepIndex = -1; // Current step being displayed

        // Node class for Huffman tree
        class HuffmanNode {
            constructor(char, freq, left = null, right = null, id = null) {
                this.char = char;
                this.freq = freq;
                this.left = left;
                this.right = right;
                this.id = id; // Unique ID for each node
                this.x = 0; // X coordinate for drawing
                this.y = 0; // Y coordinate for drawing
                this.level = 0; // Level in the tree for vertical positioning
            }
        }

        // Function to sort nodes based on frequency and then character
        function sortNodes(nodes) {
            return nodes.sort((a, b) => {
                if (a.freq !== b.freq) {
                    return a.freq - b.freq;
                }
                // Sort by character for tie-breaking, internal nodes (null char) treated last
                if (a.char === null && b.char !== null) return 1;
                if (a.char !== null && b.char === null) return -1;
                if (a.char === null && b.char === null) return 0; // Both internal, order doesn't matter much
                return a.char.localeCompare(b.char);
            });
        }

        // Function to deep copy a node and its children for state storage
        function deepCopyNode(node) {
            if (!node) return null;
            const newNode = new HuffmanNode(node.char, node.freq, null, null, node.id);
            // Recursively deep copy children
            if (node.left) {
                newNode.left = deepCopyNode(node.left);
            }
            if (node.right) {
                newNode.right = deepCopyNode(node.right);
            }
            return newNode;
        }

        // Function to build the Huffman tree step by step
        function buildHuffmanTreeSteps() {
            steps = []; // Clear previous steps
            let nodeIdCounter = 0; // Counter for new internal node IDs

            // Create initial leaf nodes. Each is a distinct object.
            let nodes = initialFrequencies
                .map(item => new HuffmanNode(item.char, item.freq, null, null, `node-${nodeIdCounter++}`))
                .sort((a, b) => a.freq - b.freq); // Initial sort by frequency

            // Store initial state (deep copy of all individual nodes)
            steps.push({
                tree: nodes.map(node => deepCopyNode(node)), // Deep copy nodes for this step
                message: 'Initial nodes sorted by frequency.',
                highlighted: [], // No nodes highlighted initially
                combinedNodes: []
            });

            // Continue merging until only one node remains (the root)
            while (nodes.length > 1) {
                // Get the two lowest frequency nodes
                const node1 = nodes.shift();
                const node2 = nodes.shift();

                // Create a new parent node. Its children are the actual node1 and node2 objects.
                const newNode = new HuffmanNode(
                    null, // Internal nodes don't have a specific character
                    node1.freq + node2.freq,
                    node1, // Direct reference to the node1 object
                    node2, // Direct reference to the node2 object
                    `node-${nodeIdCounter++}`
                );

                // Store IDs of the nodes that were just combined for highlighting
                const highlightedIds = [node1.id, node2.id];

                // Add the new node back to the array and re-sort
                nodes.push(newNode);
                nodes = sortNodes(nodes); // Re-sort after adding the new node

                // Store the state for the current step (deep copy of the current 'forest' of nodes)
                // This deep copy correctly preserves the new tree structure for this step.
                steps.push({
                    tree: nodes.map(node => deepCopyNode(node)),
                    message: `Merged '${node1.char || node1.freq}' (${node1.freq}) and '${node2.char || node2.freq}' (${node2.freq}) to form a new node with frequency ${newNode.freq}.`,
                    highlighted: highlightedIds,
                    combinedNodes: [newNode.id]
                });
            }

            // The final step is the complete tree
            if (nodes.length === 1) {
                steps.push({
                    tree: nodes.map(node => deepCopyNode(node)), // Deep copy the final root
                    message: 'Huffman tree construction complete!',
                    highlighted: [],
                    combinedNodes: []
                });
            }
        }

        // Function to calculate node positions for drawing (tree builds upwards from leaves)
        function calculateNodePositions(nodes) {
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const nodeRadius = 25;
            const horizontalSpacing = 60; // Min space between nodes
            const verticalSpacing = 70; // Space between levels

            // Use a map to store all nodes by their ID for easy lookup
            const nodeMap = new Map();
            nodes.forEach(node => nodeMap.set(node.id, node));

            // Find all 'root' nodes in the current set (nodes that are not children of any other node)
            const currentRoots = nodes.filter(node => {
                let isChild = false;
                for (const otherNode of nodes) {
                    if ((otherNode.left && otherNode.left.id === node.id) || (otherNode.right && otherNode.right.id === node.id)) {
                        isChild = true;
                        break;
                    }
                }
                return !isChild;
            });

            // Calculate levels (distance from leaves) for all reachable nodes
            let maxLevel = 0;
            const queueForLevels = [];
            const visitedForLevels = new Set();

            // Initialize leaves at level 0 and add to queue
            nodes.forEach(node => {
                if (!node.left && !node.right) {
                    node.level = 0;
                    queueForLevels.push(node);
                    visitedForLevels.add(node.id);
                }
            });

            // BFS to assign levels upwards
            let queueIndex = 0;
            while (queueIndex < queueForLevels.length) {
                const node = queueForLevels[queueIndex++];
                maxLevel = Math.max(maxLevel, node.level);

                // Find parents of current node and assign levels
                nodes.forEach(parentNode => {
                    if ((parentNode.left && parentNode.left.id === node.id) || (parentNode.right && parentNode.right.id === node.id)) {
                        if (!visitedForLevels.has(parentNode.id)) {
                            parentNode.level = node.level + 1;
                            queueForLevels.push(parentNode);
                            visitedForLevels.add(parentNode.id);
                        }
                    }
                });
            }

            // Perform post-order traversal to assign X coordinates
            // Leaf nodes get fixed X positions, internal nodes get average of children's X
            let currentLeafX = nodeRadius + horizontalSpacing; // Start X for leftmost leaf
            const assignedX = new Map(); // Store assigned X positions

            function assignXRecursive(node) {
                if (!node) return;

                if (node.left) assignXRecursive(node.left);
                if (node.right) assignXRecursive(node.right);

                if (!node.left && !node.right) { // Leaf node
                    node.x = currentLeafX;
                    currentLeafX += nodeRadius * 2 + horizontalSpacing;
                } else if (node.left && node.right) { // Internal node with two children
                    // Use the x coordinates already determined for children
                    node.x = (node.left.x + node.right.x) / 2;
                } else if (node.left) { // Should not happen in Huffman
                    node.x = node.left.x;
                } else if (node.right) { // Should not happen
                    node.x = node.right.x;
                }
                assignedX.set(node.id, node.x); // Store X for this node
            }

            // Sort roots by character/frequency to maintain a consistent horizontal order
            // This is important for early steps where there are multiple independent trees
            currentRoots.sort((a, b) => {
                if (a.char && b.char) return a.char.localeCompare(b.char);
                if (a.char) return -1;
                if (b.char) return 1;
                return a.freq - b.freq;
            }).forEach(root => {
                assignXRecursive(root);
            });

            // Apply calculated X positions back to the actual nodes in the current step.tree
            nodes.forEach(node => {
                node.x = assignedX.get(node.id);
            });


            // Assign Y positions (building upwards from bottom)
            nodes.forEach(node => {
                node.y = canvasHeight - ((node.level * verticalSpacing) + nodeRadius + 10); // Position from bottom up
            });

            // Adjust overall tree position to be centered horizontally
            let minX = Infinity;
            let maxX = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                maxX = Math.max(maxX, node.x);
            });

            const treeWidth = maxX - minX;
            const offsetX = (canvasWidth - treeWidth) / 2 - minX;

            nodes.forEach(node => {
                node.x += offsetX;
            });
        }


        // Function to draw the tree on canvas
        function drawTree(nodes, highlightedNodes = [], combinedNodes = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            if (nodes.length === 0) return;

            // Recalculate positions for current step's nodes
            calculateNodePositions(nodes);

            // Draw lines first (children to parent, for upwards tree)
            nodes.forEach(node => {
                if (node.left) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y - nodeRadius); // Start from top of parent circle
                    ctx.lineTo(node.left.x, node.left.y + nodeRadius); // Connect to bottom of child circle
                    ctx.strokeStyle = '#64748b'; // Tailwind slate-500
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw '0' label for left branch
                    ctx.fillStyle = '#334155'; // Tailwind slate-700
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'center';
                    // Position label midway on the line
                    ctx.fillText('0', (node.x + node.left.x) / 2 - 10, (node.y - nodeRadius + node.left.y + nodeRadius) / 2 + 10);
                }
                if (node.right) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y - nodeRadius); // Start from top of parent circle
                    ctx.lineTo(node.right.x, node.right.y + nodeRadius); // Connect to bottom of child circle
                    ctx.strokeStyle = '#64748b';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw '1' label for right branch
                    ctx.fillStyle = '#334155';
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'center';
                    // Position label midway on the line
                    ctx.fillText('1', (node.x + node.right.x) / 2 + 10, (node.y - nodeRadius + node.right.y + nodeRadius) / 2 + 10);
                }
            });

            // Draw nodes (after lines, so nodes appear on top)
            nodes.forEach(node => {
                const isHighlighted = highlightedNodes.includes(node.id);
                const isCombined = combinedNodes.includes(node.id);
                const nodeRadius = 25; // Re-define locally for use in drawing

                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
                ctx.fillStyle = isCombined ? '#059669' : (isHighlighted ? '#f59e0b' : '#3b82f6'); // Green for combined, orange for highlighted, blue for others
                ctx.strokeStyle = isCombined ? '#047857' : (isHighlighted ? '#d97706' : '#2563eb');
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();

                // Draw frequency
                ctx.fillStyle = 'white';
                ctx.font = '16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Position frequency slightly above the center
                ctx.fillText(node.freq, node.x, node.y + (node.char !== null ? 8 : 0));

                // Draw character (if it's a leaf node)
                if (node.char !== null) {
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Inter';
                    // Position character slightly below the center
                    ctx.fillText(node.char, node.x, node.y - 12);
                }
            });
        }

        // Render current step
        function renderStep() {
            if (currentStepIndex >= 0 && currentStepIndex < steps.length) {
                const currentStep = steps[currentStepIndex];
                // Pass the deep-copied tree nodes directly for drawing
                stepInfoElement.innerHTML = currentStep.message;
                // Ensure nodes array is always flattened for drawTree
                let nodesToDraw = [];
                const queue = [...currentStep.tree];
                const visitedDrawing = new Set();
                while(queue.length > 0) {
                    const node = queue.shift();
                    if (node && !visitedDrawing.has(node.id)) {
                        visitedDrawing.add(node.id);
                        nodesToDraw.push(node);
                        if (node.left) queue.push(node.left);
                        if (node.right) queue.push(node.right);
                    }
                }
                drawTree(nodesToDraw, currentStep.highlighted, currentStep.combinedNodes);
            } else {
                stepInfoElement.innerHTML = 'Press "Next Step" to start.';
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas if no step
            }
            updateButtonStates();
        }

        // Update button disabled states
        function updateButtonStates() {
            prevBtn.disabled = currentStepIndex <= 0;
            nextBtn.disabled = currentStepIndex >= steps.length - 1;
            resetBtn.disabled = currentStepIndex === -1;
        }

        // Event Listeners
        nextBtn.addEventListener('click', () => {
            if (currentStepIndex < steps.length - 1) {
                currentStepIndex++;
                renderStep();
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                renderStep();
            }
        });

        resetBtn.addEventListener('click', () => {
            currentStepIndex = -1; // Go back to before the first step
            buildHuffmanTreeSteps(); // Rebuild steps to ensure fresh start
            renderStep();
        });

        // Initialize on window load
        window.onload = function() {
            // Set canvas dimensions dynamically for responsiveness
            const containerWidth = canvas.parentElement.offsetWidth;
            canvas.width = containerWidth > 900 ? 900 : containerWidth - 30; // Max 900px, or container width
            canvas.height = Math.min(window.innerHeight * 0.8, 600); // Max 80% of viewport height, or 600px

            buildHuffmanTreeSteps();
            renderStep();
        };

        // Handle window resize
        window.addEventListener('resize', () => {
            const containerWidth = canvas.parentElement.offsetWidth;
            canvas.width = containerWidth > 900 ? 900 : containerWidth - 30;
            canvas.height = Math.min(window.innerHeight * 0.8, 600);
            renderStep(); // Redraw tree on resize
        });

    </script>
</body>
</html>
