<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Tree Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Soft shadow */
            padding: 1.5rem;
            max-width: 95vw; /* Increased max width */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
        }
        canvas {
            border: 1px solid #cbd5e1; /* Light gray border */
            background-color: #fdfefe; /* Slightly off-white for canvas */
            border-radius: 0.5rem;
            display: block;
            width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
            max-height: 85vh; /* Increased max canvas height */
        }
        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap; /* Allow controls to wrap on small screens */
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem; /* More rounded buttons */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: none; /* No default border */
        }
        .btn-primary {
            background-color: #3b82f6; /* Blue */
            color: white;
        }
        .btn-primary:hover {
            background-color: #2563eb; /* Darker blue */
            transform: translateY(-2px); /* Slight lift effect */
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Light gray */
            color: #334155; /* Darker text */
        }
        .btn-secondary:hover {
            background-color: #cbd5e1; /* Even darker gray */
            transform: translateY(-2px);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .step-info {
            font-size: 1.125rem; /* Larger text */
            font-weight: 500;
            color: #475569; /* Slate gray */
            text-align: center;
            min-height: 2.5rem; /* Reserve space to prevent layout shifts */
        }
        .node-circle {
            fill: #60a5fa; /* Blue for circles */
            stroke: #3b82f6;
            stroke-width: 2;
        }
        .node-text {
            font-size: 14px;
            fill: white;
            text-anchor: middle;
            alignment-baseline: central;
        }
        .label-text {
            font-size: 12px;
            fill: #334155;
            text-anchor: middle;
            alignment-baseline: central;
        }
        .line {
            stroke: #64748b; /* Gray for lines */
            stroke-width: 2;
        }
        .current-nodes-highlight {
            font-weight: bold;
            color: #059669; /* Green for highlighting active nodes */
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .container {
                max-width: 1000px; /* Wider on desktop */
                padding: 2rem;
            }
            .controls {
                flex-wrap: nowrap; /* Keep controls in a single row on desktop */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-2xl font-bold text-gray-800 mb-4">Huffman Tree Construction</h1>
        <p class="step-info" id="step-info"></p>
        <canvas id="huffmanCanvas"></canvas>
        <div class="controls">
            <button id="prevBtn" class="btn btn-secondary">Previous Step</button>
            <button id="nextBtn" class="btn btn-primary">Next Step</button>
            <button id="resetBtn" class="btn btn-secondary">Reset</button>
        </div>
    </div>

    <script>
        // Get canvas and its context
        const canvas = document.getElementById('huffmanCanvas');
        const ctx = canvas.getContext('2d');
        const stepInfoElement = document.getElementById('step-info');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const resetBtn = document.getElementById('resetBtn');

        // Initial character frequencies based on the new image
        const initialFrequencies = [
            { char: 'A', freq: 4 },
            { char: 'B', freq: 7 },
            { char: 'C', freq: 3 },
            { char: 'D', freq: 2 },
            { char: 'E', freq: 4 },
        ];

        let steps = []; // Stores the state of the tree at each step
        let currentStepIndex = -1; // Current step being displayed

        // Global map to store all created nodes with their original references.
        // This is crucial for reconstructing the full tree structure at each step.
        const allNodesMap = new Map(); // id -> HuffmanNode object

        // Node class for Huffman tree
        class HuffmanNode {
            constructor(char, freq, left = null, right = null, id = null) {
                this.char = char;
                this.freq = freq;
                this.left = left;
                this.right = right;
                this.id = id; // Unique ID for each node
                this.x = 0; // X coordinate for drawing
                this.y = 0; // Y coordinate for drawing
                this.level = 0; // Level in the tree for vertical positioning
            }
        }

        // Function to sort nodes based on frequency and then character
        function sortNodes(nodes) {
            return nodes.sort((a, b) => {
                if (a.freq !== b.freq) {
                    return a.freq - b.freq;
                }
                // For tie-breaking, sort by character (internal nodes with null char come after actual characters)
                if (a.char === null && b.char !== null) return 1;
                if (a.char !== null && b.char === null) return -1;
                if (a.char === null && b.char === null) return 0; // Both internal, their relative order doesn't impact tree shape for sorting
                return a.char.localeCompare(b.char);
            });
        }

        // Function to build the Huffman tree step by step
        function buildHuffmanTreeSteps() {
            // Clear previous state
            allNodesMap.clear();
            steps = [];
            let nodeIdCounter = 0; // Start ID counter from 0 for all nodes

            // Initialize leaf nodes and add them to the global map
            let nodes = initialFrequencies
                .map(item => {
                    const node = new HuffmanNode(item.char, item.freq, null, null, `node-${nodeIdCounter++}`);
                    allNodesMap.set(node.id, node);
                    return node;
                })
                .sort((a, b) => a.freq - b.freq); // Initial sort by frequency

            // Store initial state (all individual nodes' IDs)
            steps.push({
                activeNodeIds: nodes.map(node => node.id), // Store IDs of nodes currently considered 'roots'
                message: 'Initial nodes sorted by frequency.',
                highlighted: [],
                combinedNodes: []
            });

            // Continue merging until only one node remains (the root)
            while (nodes.length > 1) {
                // Get the two lowest frequency nodes
                const node1 = nodes.shift();
                const node2 = nodes.shift();

                // Create a new parent node. Children are direct references to existing nodes.
                const newNode = new HuffmanNode(
                    null, // Internal nodes don't have a specific character
                    node1.freq + node2.freq,
                    node1, // Reference to the actual node1 object
                    node2, // Reference to the actual node2 object
                    `node-${nodeIdCounter++}`
                );

                allNodesMap.set(newNode.id, newNode); // Add new node to the global map

                nodes.push(newNode);
                nodes = sortNodes(nodes); // Re-sort after adding the new node

                // Store the state for the current step (IDs of active roots, highlighted/combined)
                steps.push({
                    activeNodeIds: nodes.map(node => node.id),
                    message: `Merged '${node1.char || node1.freq}' (${node1.freq}) and '${node2.char || node2.freq}' (${node2.freq}) to form a new node with frequency ${newNode.freq}.`,
                    highlighted: [node1.id, node2.id], // Highlight the nodes that were just merged
                    combinedNodes: [newNode.id] // Highlight the newly formed node
                });
            }

            // The final step is the complete tree
            if (nodes.length === 1) {
                steps.push({
                    activeNodeIds: nodes.map(node => node.id), // ID of the final root
                    message: 'Huffman tree construction complete!',
                    highlighted: [],
                    combinedNodes: []
                });
            }
        }

        // Function to reconstruct the actual HuffmanNode objects for drawing a given step
        // This creates a temporary graph of connected nodes specifically for the drawing pass.
        function reconstructTreeForStep(activeNodeIds) {
            const nodesForDrawing = new Map(); // id -> new HuffmanNode instance for this drawing pass

            // Helper to recursively create a drawable node and its children
            function createDrawableNode(originalNodeId) {
                if (!originalNodeId) return null; // Base case for no child
                if (nodesForDrawing.has(originalNodeId)) {
                    return nodesForDrawing.get(originalNodeId); // Already created for this pass
                }

                const originalNode = allNodesMap.get(originalNodeId);
                if (!originalNode) {
                    console.error(`Original node with ID ${originalNodeId} not found in map.`);
                    return null;
                }

                // Create a new instance for drawing, copy relevant properties
                const drawableNode = new HuffmanNode(
                    originalNode.char,
                    originalNode.freq,
                    null, // Will set children after they are created
                    null,
                    originalNode.id // Keep the original ID for highlighting
                );
                nodesForDrawing.set(originalNode.id, drawableNode); // Add to map for current pass

                // Recursively set children using their IDs to resolve actual node objects
                drawableNode.left = createDrawableNode(originalNode.left ? originalNode.left.id : null);
                drawableNode.right = createDrawableNode(originalNode.right ? originalNode.right.id : null);

                return drawableNode;
            }

            // Start reconstruction from the active roots of the current step
            const currentRootsForDrawing = [];
            activeNodeIds.forEach(id => {
                const rootNode = createDrawableNode(id);
                if (rootNode) {
                    currentRootsForDrawing.push(rootNode);
                }
            });

            // Return a flattened list of all nodes that are part of these reconstructed trees
            const flattenedNodes = [];
            nodesForDrawing.forEach(node => flattenedNodes.push(node));
            return flattenedNodes;
        }


        // Function to calculate node positions for drawing (upside down tree)
        function calculateNodePositions(nodes) {
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const nodeRadius = 25;
            const horizontalSpacing = 50; // Min space between sibling nodes or initial leaf nodes
            const verticalSpacing = 70; // Space between levels

            // 1. Assign levels to all nodes based on their current "roots"
            let maxLevel = 0;
            const visitedForLevel = new Set();
            const queueForLevel = [];

            // Identify all nodes that are currently 'roots' in the conceptual forest
            const currentRoots = nodes.filter(node => {
                let isChild = false;
                for (const otherNode of nodes) {
                    if ((otherNode.left && otherNode.left.id === node.id) || (otherNode.right && otherNode.right.id === node.id)) {
                        isChild = true;
                        break;
                    }
                }
                return !isChild;
            });

            currentRoots.forEach(root => {
                root.level = 0;
                queueForLevel.push(root);
                visitedForLevel.add(root.id);
            });

            while (queueForLevel.length > 0) {
                const node = queueForLevel.shift();
                maxLevel = Math.max(maxLevel, node.level);

                if (node.left && !visitedForLevel.has(node.left.id)) {
                    node.left.level = node.level + 1;
                    queueForLevel.push(node.left);
                    visitedForLevel.add(node.left.id);
                }
                if (node.right && !visitedForLevel.has(node.right.id)) {
                    node.right.level = node.level + 1;
                    queueForLevel.push(node.right);
                    visitedForLevel.add(node.right.id);
                }
            }

            // 2. Assign initial X positions to leaves and then average for internal nodes
            // This is done for each independent tree (root) in the current forest.

            let globalNextLeafX = nodeRadius + horizontalSpacing;

            // Helper function to perform post-order traversal and assign X positions
            function assignXPositions(node) {
                if (!node) return;

                if (node.left) {
                    assignXPositions(node.left);
                }
                if (node.right) {
                    assignXPositions(node.right);
                }

                if (!node.left && !node.right) { // It's a leaf node
                    node.x = globalNextLeafX;
                    globalNextLeafX += nodeRadius * 2 + horizontalSpacing;
                } else if (node.left && node.right) { // Internal node with two children
                    node.x = (node.left.x + node.right.x) / 2;
                } else if (node.left) { // Only left child (shouldn't happen in Huffman, but for robustness)
                    node.x = node.left.x;
                } else if (node.right) { // Only right child (shouldn't happen in Huffman, but for robustness)
                    node.x = node.right.x;
                }
            }

            // Apply assignXPositions to each independent root in the current forest
            // Sort roots by their (potential) leftmost leaf's X position to maintain overall order
            currentRoots.sort((a, b) => {
                // A very simplified sort to maintain order for multiple initial trees
                // This could be improved with a more robust tree sorting algorithm if necessary
                return a.char?.localeCompare(b.char) || a.freq - b.freq;
            }).forEach(root => {
                 // Reset globalNextLeafX for each independent tree to prevent large gaps
                 // This is a common strategy for laying out multiple distinct trees side-by-side
                 // We need to calculate its starting position dynamically or based on cumulative widths.
                 // For now, let's just make sure it keeps incrementing to ensure separation.
                 if (globalNextLeafX < (nodeRadius + horizontalSpacing)) { // If it was reset to 0 or very small
                     globalNextLeafX = nodeRadius + horizontalSpacing;
                 } else { // Add some padding between trees
                     globalNextLeafX += nodeRadius * 2;
                 }
                assignXPositions(root);
            });


            // 3. Assign Y positions (upside down)
            nodes.forEach(node => {
                node.y = (node.level * verticalSpacing) + nodeRadius + 40; // Position from top down, adding initial padding
            });

            // 4. Center the entire layout horizontally
            let minX = Infinity;
            let maxX = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                maxX = Math.max(maxX, node.x);
            });

            const treeWidth = maxX - minX;
            // Ensure trees are not too far to the left or right, add some base padding
            const offsetX = (canvasWidth - treeWidth) / 2 - minX;

            nodes.forEach(node => {
                node.x += offsetX;
            });
        }


        // Function to draw the tree on canvas
        function drawTree(nodes, highlightedNodes = [], combinedNodes = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            if (nodes.length === 0) return;

            // Recalculate positions for current step (this will update x, y, level properties on nodes)
            calculateNodePositions(nodes);

            // Draw lines first (parent to children)
            nodes.forEach(node => {
                // Check if node is an internal node with children to draw lines from
                if (node.left || node.right) {
                    if (node.left) {
                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y + nodeRadius); // Start from bottom of parent circle
                        ctx.lineTo(node.left.x, node.left.y - nodeRadius); // Connect to top of child circle
                        ctx.strokeStyle = '#64748b'; // Tailwind slate-500
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Draw '0' label for left branch
                        ctx.fillStyle = '#334155'; // Tailwind slate-700
                        ctx.font = '12px Inter';
                        ctx.textAlign = 'center';
                        ctx.fillText('0', (node.x + node.left.x) / 2 - 10, (node.y + nodeRadius + node.left.y - nodeRadius) / 2 - 10);
                    }
                    if (node.right) {
                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y + nodeRadius); // Start from bottom of parent circle
                        ctx.lineTo(node.right.x, node.right.y - nodeRadius); // Connect to top of child circle
                        ctx.strokeStyle = '#64748b';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Draw '1' label for right branch
                        ctx.fillStyle = '#334155';
                        ctx.font = '12px Inter';
                        ctx.textAlign = 'center';
                        ctx.fillText('1', (node.x + node.right.x) / 2 + 10, (node.y + nodeRadius + node.right.y - nodeRadius) / 2 - 10);
                    }
                }
            });
// Draw nodes
            nodes.forEach(node => {
                const isHighlighted = highlightedNodes.includes(node.id);
                const isCombined = combinedNodes.includes(node.id);

                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
                ctx.fillStyle = isCombined ? '#059669' : (isHighlighted ? '#f59e0b' : '#3b82f6'); // Green for combined, orange for highlighted, blue for others
                ctx.strokeStyle = isCombined ? '#047857' : (isHighlighted ? '#d97706' : '#2563eb');
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();

                // Draw frequency
                ctx.fillStyle = 'white';
                ctx.font = '16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Adjust frequency and character position for upside down tree, frequency above character
                ctx.fillText(node.freq, node.x, node.y - (node.char !== null ? 8 : 0));

                // Draw character (if it's a leaf node or an internal node that shows a character)
                if (node.char !== null) {
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Inter';
                    ctx.fillText(node.char, node.x, node.y + 12);
                }
            });
        }

        // Render current step
        function renderStep() {
            if (currentStepIndex >= 0 && currentStepIndex < steps.length) {
                const currentStep = steps[currentStepIndex];
                // Reconstruct the tree structure for drawing based on the active nodes in this step
                const nodesToDraw = reconstructTreeForStep(currentStep.activeNodeIds);

                stepInfoElement.innerHTML = currentStep.message;
                drawTree(nodesToDraw, currentStep.highlighted, currentStep.combinedNodes);
            } else {
                stepInfoElement.innerHTML = 'Press "Next Step" to start.';
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas if no step
            }
            updateButtonStates();
        }

        // Update button disabled states
        function updateButtonStates() {
            prevBtn.disabled = currentStepIndex <= 0;
            nextBtn.disabled = currentStepIndex >= steps.length - 1;
            resetBtn.disabled = currentStepIndex === -1;
        }

        // Event Listeners
        nextBtn.addEventListener('click', () => {
            if (currentStepIndex < steps.length - 1) {
                currentStepIndex++;
                renderStep();
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                renderStep();
            }
        });

        resetBtn.addEventListener('click', () => {
            currentStepIndex = -1; // Go back to before the first step
            // Rebuild steps to ensure fresh start, clearing allNodesMap
            buildHuffmanTreeSteps();
            renderStep();
        });

        // Initialize on window load
        window.onload = function() {
            // Set canvas dimensions dynamically for responsiveness
            const containerWidth = canvas.parentElement.offsetWidth;
            canvas.width = containerWidth > 1000 ? 1000 : containerWidth - 30; // Max 1000px, or container width
            canvas.height = Math.min(window.innerHeight * 0.85, 700); // Max 85% of viewport height, or 700px

            buildHuffmanTreeSteps(); // Initial construction
            renderStep(); // Render the first step (or initial state)
        };

        // Handle window resize
        window.addEventListener('resize', () => {
            const containerWidth = canvas.parentElement.offsetWidth;
            canvas.width = containerWidth > 1000 ? 1000 : containerWidth - 30;
            canvas.height = Math.min(window.innerHeight * 0.85, 700);
            renderStep(); // Redraw tree on resize
        });

    </script>
</body>
</html>
       
