<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Huffman Tree Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
        }
        .container {
            background-color: #ffffff;
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Soft shadow */
            padding: 1.5rem;
            max-width: 90vw; /* Max width relative to viewport */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            align-items: center;
        }
        canvas {
            border: 1px solid #cbd5e1; /* Light gray border */
            background-color: #fdfefe; /* Slightly off-white for canvas */
            border-radius: 0.5rem;
            display: block;
            width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
            max-height: 70vh; /* Limit canvas height */
        }
        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap; /* Allow controls to wrap on small screens */
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem; /* More rounded buttons */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border: none; /* No default border */
        }
        .btn-primary {
            background-color: #3b82f6; /* Blue */
            color: white;
        }
        .btn-primary:hover {
            background-color: #2563eb; /* Darker blue */
            transform: translateY(-2px); /* Slight lift effect */
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Light gray */
            color: #334155; /* Darker text */
        }
        .btn-secondary:hover {
            background-color: #cbd5e1; /* Even darker gray */
            transform: translateY(-2px);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .step-info {
            font-size: 1.125rem; /* Larger text */
            font-weight: 500;
            color: #475569; /* Slate gray */
            text-align: center;
            min-height: 2.5rem; /* Reserve space to prevent layout shifts */
        }
        .node-circle {
            fill: #60a5fa; /* Blue for circles */
            stroke: #3b82f6;
            stroke-width: 2;
        }
        .node-text {
            font-size: 14px;
            fill: white;
            text-anchor: middle;
            alignment-baseline: central;
        }
        .label-text {
            font-size: 12px;
            fill: #334155;
            text-anchor: middle;
            alignment-baseline: central;
        }
        .line {
            stroke: #64748b; /* Gray for lines */
            stroke-width: 2;
        }
        .current-nodes-highlight {
            font-weight: bold;
            color: #059669; /* Green for highlighting active nodes */
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .container {
                max-width: 800px; /* Wider on desktop */
                padding: 2rem;
            }
            .controls {
                flex-wrap: nowrap; /* Keep controls in a single row on desktop */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-2xl font-bold text-gray-800 mb-4">Huffman Tree Construction</h1>
        <p class="step-info" id="step-info"></p>
        <canvas id="huffmanCanvas"></canvas>
        <div class="controls">
            <button id="prevBtn" class="btn btn-secondary">Previous Step</button>
            <button id="nextBtn" class="btn btn-primary">Next Step</button>
            <button id="resetBtn" class="btn btn-secondary">Reset</button>
        </div>
    </div>

    <script>
        // Get canvas and its context
        const canvas = document.getElementById('huffmanCanvas');
        const ctx = canvas.getContext('2d');
        const stepInfoElement = document.getElementById('step-info');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const resetBtn = document.getElementById('resetBtn');

        // Initial character frequencies as provided in the image
        const initialFrequencies = [
            { char: 'A', freq: 1 },
            { char: 'G', freq: 1 },
            { char: 'M', freq: 1 },
            { char: 'T', freq: 1 },
            { char: 'E', freq: 2 },
            { char: 'H', freq: 2 },
            { char: '_', freq: 3 }, // Space character
            { char: 'I', freq: 3 },
            { char: 'S', freq: 5 },
        ];

        let steps = []; // Stores the state of the tree at each step
        let currentStepIndex = -1; // Current step being displayed

        // Node class for Huffman tree
        class HuffmanNode {
            constructor(char, freq, left = null, right = null, id = null) {
                this.char = char;
                this.freq = freq;
                this.left = left;
                this.right = right;
                this.id = id; // Unique ID for each node
                this.x = 0; // X coordinate for drawing
                this.y = 0; // Y coordinate for drawing
                this.level = 0; // Level in the tree for vertical positioning
            }
        }

        // Function to sort nodes based on frequency and then character
        function sortNodes(nodes) {
            return nodes.sort((a, b) => {
                if (a.freq !== b.freq) {
                    return a.freq - b.freq;
                }
                // Sort by character for tie-breaking, treat internal nodes (null char) last
                if (a.char === null && b.char !== null) return 1;
                if (a.char !== null && b.char === null) return -1;
                if (a.char === null && b.char === null) return 0; // Both internal, order doesn't matter much
                return a.char.localeCompare(b.char);
            });
        }

        // Function to build the Huffman tree step by step
        function buildHuffmanTreeSteps() {
            let nodes = initialFrequencies
                .map((item, index) => new HuffmanNode(item.char, item.freq, null, null, `node-${index}`))
                .sort((a, b) => a.freq - b.freq); // Initial sort by frequency

            steps = [];
            let nodeIdCounter = nodes.length; // Counter for new internal node IDs

            // Store initial state (all individual nodes)
            steps.push({
                tree: JSON.parse(JSON.stringify(nodes)), // Deep copy nodes
                message: 'Initial nodes sorted by frequency.',
                highlighted: [], // No nodes highlighted initially
                combinedNodes: []
            });

            // Continue merging until only one node remains (the root)
            while (nodes.length > 1) {
                // Get the two lowest frequency nodes
                const node1 = nodes.shift();
                const node2 = nodes.shift();

                // Create a new parent node
                const newNode = new HuffmanNode(
                    null, // Internal nodes don't have a specific character
                    node1.freq + node2.freq,
                    node1,
                    node2,
                    `node-${nodeIdCounter++}`
                );

                // Add the new node back to the array and re-sort
                nodes.push(newNode);
                nodes = sortNodes(nodes); // Re-sort after adding the new node

                // Store the state for the current step
                steps.push({
                    tree: JSON.parse(JSON.stringify(nodes)), // Deep copy the current list of 'root' nodes
                    message: `Merged '${node1.char || 'internal'}' (${node1.freq}) and '${node2.char || 'internal'}' (${node2.freq}) to form a new node with frequency ${newNode.freq}.`,
                    highlighted: [node1.id, node2.id], // Highlight the nodes that were just merged
                    combinedNodes: [newNode.id] // Highlight the newly formed node
                });
            }

            // The final step is the complete tree
            if (nodes.length === 1) {
                steps.push({
                    tree: JSON.parse(JSON.stringify(nodes)), // Deep copy the final root
                    message: 'Huffman tree construction complete!',
                    highlighted: [],
                    combinedNodes: []
                });
            }
        }

        // Function to calculate node positions for drawing
        function calculateNodePositions(nodes) {
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const nodeRadius = 25;
            const horizontalSpacing = 60; // Min space between nodes
            const verticalSpacing = 70; // Space between levels

            // Calculate tree levels and maximum depth
            let maxLevel = 0;
            const visited = new Set();
            const queue = [];

            // Find all nodes that are currently "roots" in the visualization step
            const currentRoots = nodes.filter(node => {
                // A node is a root if it's not a child of any other node in the current set
                return !nodes.some(otherNode => otherNode.left === node || otherNode.right === node);
            });

            // Start BFS from the current roots to determine levels
            currentRoots.forEach(root => {
                root.level = 0;
                queue.push(root);
                visited.add(root.id);
            });

            while (queue.length > 0) {
                const node = queue.shift();
                maxLevel = Math.max(maxLevel, node.level);

                if (node.left) {
                    node.left.level = node.level + 1;
                    if (!visited.has(node.left.id)) {
                        queue.push(node.left);
                        visited.add(node.left.id);
                    }
                }
                if (node.right) {
                    node.right.level = node.level + 1;
                    if (!visited.has(node.right.id)) {
                        queue.push(node.right);
                        visited.add(node.right.id);
                    }
                }
            }

            // Assign X positions based on inorder traversal for a balanced look
            // This is complex for a dynamic tree, simpler approach: distribute evenly
            // For a single tree, standard tree layout algorithms apply.
            // For multiple roots (early steps), we need to layout them side-by-side.

            let currentX = nodeRadius + horizontalSpacing;
            const levelMap = new Map(); // Map to store nodes by level

            // Re-initialize levels for accurate horizontal positioning within a step
            nodes.forEach(node => {
                if (!levelMap.has(node.level)) {
                    levelMap.set(node.level, []);
                }
                levelMap.get(node.level).push(node);
            });

            // Iterate from deepest level up to position nodes
            for (let level = maxLevel; level >= 0; level--) {
                const nodesOnLevel = levelMap.get(level);
                if (!nodesOnLevel) continue;

                // Sort nodes on this level to maintain consistent horizontal ordering
                nodesOnLevel.sort((a, b) => {
                    // Try to sort by char if available, otherwise by freq, or just maintain existing order
                    if (a.char && b.char) return a.char.localeCompare(b.char);
                    return a.freq - b.freq;
                });

                nodesOnLevel.forEach(node => {
                    if (node.left && node.right) {
                        // Position parent node centrally above its children
                        node.x = (node.left.x + node.right.x) / 2;
                    } else {
                        // Leaf node or root of a smaller tree in early steps
                        node.x = currentX;
                        currentX += nodeRadius * 2 + horizontalSpacing;
                    }
                    node.y = canvasHeight - (node.level * verticalSpacing) - nodeRadius - 10; // Position from bottom up
                });
            }

            // Adjust overall tree position to be centered horizontally
            let minX = Infinity;
            let maxX = -Infinity;
            nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                maxX = Math.max(maxX, node.x);
            });

            const treeWidth = maxX - minX;
            const offsetX = (canvasWidth - treeWidth) / 2 - minX;

            nodes.forEach(node => {
                node.x += offsetX;
            });
        }


        // Function to draw the tree on canvas
        function drawTree(nodes, highlightedNodes = [], combinedNodes = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            if (nodes.length === 0) return;

            // Recalculate positions for current step
            calculateNodePositions(nodes);

            // Draw lines first (children to parent)
            nodes.forEach(node => {
                if (node.left) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(node.left.x, node.left.y + 25); // Connect to child's top
                    ctx.strokeStyle = '#64748b'; // Tailwind slate-500
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw '0' label for left branch
                    ctx.fillStyle = '#334155'; // Tailwind slate-700
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText('0', (node.x + node.left.x) / 2 - 10, (node.y + node.left.y + 25) / 2 - 10);
                }
                if (node.right) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y);
                    ctx.lineTo(node.right.x, node.right.y + 25); // Connect to child's top
                    ctx.strokeStyle = '#64748b';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw '1' label for right branch
                    ctx.fillStyle = '#334155';
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText('1', (node.x + node.right.x) / 2 + 10, (node.y + node.right.y + 25) / 2 - 10);
                }
            });

            // Draw nodes
            nodes.forEach(node => {
                const isHighlighted = highlightedNodes.includes(node.id);
                const isCombined = combinedNodes.includes(node.id);

                ctx.beginPath();
                ctx.arc(node.x, node.y, 25, 0, Math.PI * 2);
                ctx.fillStyle = isCombined ? '#059669' : (isHighlighted ? '#f59e0b' : '#3b82f6'); // Green for combined, orange for highlighted, blue for others
                ctx.strokeStyle = isCombined ? '#047857' : (isHighlighted ? '#d97706' : '#2563eb');
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();

                // Draw frequency
                ctx.fillStyle = 'white';
                ctx.font = '16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.freq, node.x, node.y - 10);

                // Draw character (if it's a leaf node or an internal node that shows a character)
                if (node.char !== null) {
                    ctx.fillStyle = 'white';
                    ctx.font = '14px Inter';
                    ctx.fillText(node.char === '_' ? 'Space' : node.char, node.x, node.y + 12);
                }
            });
        }

        // Render current step
        function renderStep() {
            if (currentStepIndex >= 0 && currentStepIndex < steps.length) {
                const currentStep = steps[currentStepIndex];
                const nodesToDraw = [];

                // Create a flattened list of all nodes relevant to the current step's tree(s)
                const queue = [...currentStep.tree];
                const seenNodes = new Set();
                while (queue.length > 0) {
                    const node = queue.shift();
                    if (node && !seenNodes.has(node.id)) {
                        seenNodes.add(node.id);
                        nodesToDraw.push(node);
                        if (node.left) queue.push(node.left);
                        if (node.right) queue.push(node.right);
                    }
                }

                stepInfoElement.innerHTML = currentStep.message;
                drawTree(nodesToDraw, currentStep.highlighted, currentStep.combinedNodes);
            } else {
                stepInfoElement.innerHTML = 'Press "Next Step" to start.';
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas if no step
            }
            updateButtonStates();
        }

        // Update button disabled states
        function updateButtonStates() {
            prevBtn.disabled = currentStepIndex <= 0;
            nextBtn.disabled = currentStepIndex >= steps.length - 1;
            resetBtn.disabled = currentStepIndex === -1;
        }

        // Event Listeners
        nextBtn.addEventListener('click', () => {
            if (currentStepIndex < steps.length - 1) {
                currentStepIndex++;
                renderStep();
            }
        });

        prevBtn.addEventListener('click', () => {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                renderStep();
            }
        });

        resetBtn.addEventListener('click', () => {
            currentStepIndex = -1; // Go back to before the first step
            buildHuffmanTreeSteps(); // Rebuild steps to ensure fresh start
            renderStep();
        });

        // Initialize on window load
        window.onload = function() {
            // Set canvas dimensions dynamically for responsiveness
            const containerWidth = canvas.parentElement.offsetWidth;
            canvas.width = containerWidth > 800 ? 800 : containerWidth - 30; // Max 800px, or container width
            canvas.height = Math.min(window.innerHeight * 0.7, 500); // Max 70% of viewport height, or 500px

            buildHuffmanTreeSteps();
            renderStep();
        };

        // Handle window resize
        window.addEventListener('resize', () => {
            const containerWidth = canvas.parentElement.offsetWidth;
            canvas.width = containerWidth > 800 ? 800 : containerWidth - 30;
            canvas.height = Math.min(window.innerHeight * 0.7, 500);
            renderStep(); // Redraw tree on resize
        });

    </script>
</body>
</html>

